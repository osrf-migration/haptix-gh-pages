{"links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/4/comments/5974288.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/4/_/diff#comment-5974288"}}, "parent": {"id": 5961109, "links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/4/comments/5961109.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/4/_/diff#comment-5961109"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/4.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/4"}}, "title": "Update to the simulation API"}, "content": {"raw": "I don't see how the user benefits from unimplemented functions, especially if one simulator implements one subset of functions and the other simulator implements a partially overlapping subset. I can imagine several concrete scenarios, all of them undesirable:\n\n1. people write code without error checking, things go bad, and they waste their time debugging.\n\n2. people write code with error checking, and get error \"not yet implemented\". now what?  presumably they called the function because the program logic required it.  how are they supposed to proceed?  the only solution is lots of if-then statements. this is actually worse than having two separate code bases; they now have to support any combination of unimplemented functions, so the number of execution paths is more like 2^N.\n\n3. people read the documentation, see that some functions are not yet implemented, and ignore them -- which means we wasted our time.\n", "markup": "markdown", "html": "<p>I don't see how the user benefits from unimplemented functions, especially if one simulator implements one subset of functions and the other simulator implements a partially overlapping subset. I can imagine several concrete scenarios, all of them undesirable:</p>\n<ol>\n<li>\n<p>people write code without error checking, things go bad, and they waste their time debugging.</p>\n</li>\n<li>\n<p>people write code with error checking, and get error \"not yet implemented\". now what?  presumably they called the function because the program logic required it.  how are they supposed to proceed?  the only solution is lots of if-then statements. this is actually worse than having two separate code bases; they now have to support any combination of unimplemented functions, so the number of execution paths is more like 2^N.</p>\n</li>\n<li>\n<p>people read the documentation, see that some functions are not yet implemented, and ignore them -- which means we wasted our time.</p>\n</li>\n</ol>", "type": "rendered"}, "created_on": "2015-03-31T03:39:57.004770+00:00", "user": {"display_name": "Emo Todorov", "uuid": "{c84af488-b11e-458d-9817-1aeafde381d2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D"}, "html": {"href": "https://bitbucket.org/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D/"}, "avatar": {"href": "https://bitbucket.org/account/emotodorov/avatar/"}}, "nickname": "emotodorov", "type": "user", "account_id": null}, "updated_on": "2015-03-31T03:42:43.673745+00:00", "type": "pullrequest_comment", "id": 5974288}