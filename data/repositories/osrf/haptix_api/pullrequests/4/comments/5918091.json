{"links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/4/comments/5918091.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/4/_/diff#comment-5918091"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 4, "links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/4.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/4"}}, "title": "Update to the simulation API"}, "content": {"raw": "SUMMARY:\n\nI wasn't sure if this is intended to be standardized, but Justin tells me it is.  I think we should aim for a much smaller \"world API\" that can have well-defined behavior with respect to both simulators.  We can add to it later if users want specific functionality that can be implemented on both sides.  But most such functionality will be simulator-specific because the two simulators represent and simulate the system in very different ways.\n\nAs of now, the only functions I think should be standardized are:\n\n\n```\n#!c\n\nhxResult hxs_set_camera(const hxTransform*);\nhxResult hxs_get_camera(hxTransform*);\nhxResult hxs_get_contacts(hxContactPoints*);\nhxResult hxs_set_force(const char*, const hxVector3*);\nhxResult hxs_set_torque(const char*, const hxVector3*);\nhxResult hxs_reset(int);\nhxResult hxs_get_body(const char*, hxBodyState*); // or something like this\n\n```\n\n\n\nDETAILS:\n\n\n```\n#!c\n\nstruct _hxVector3;\nstruct _hxQuaternion;\nstruct _hxTransform;\n\n```\n\n\nThese are fine.  We may want to rename hxTransform to hxFrame though.  It is more natural to think of bodies as having position and orientation, instead of being translated and rotated relative to the world frame (although the two are mathematically equivalent).\n\n\n\n\n```\n#!c\n\nstruct _hxJoint;\n\n```\n\n\nhxSensor already contains most of this information, so I am not sure this is needed.\n\n\n\n\n```\n#!c\nstruct _hxLink;\n\n```\n\n\nThis is fine, although we should avoid mixing information about the state (i.e. position and velocity) with information that depends on the controls and applied forces (i.e. acceleration).  What if we include only the link position and velocity?  If users ask for acceleration beyond what the IMUs provide, we can provide it later, with a separate function:\n\n\n```\n#!c\n\nhxResult hxs_get_acceleration(const char* name, hxVector* linear, hxVector* angular);\n\n```\n\n\n\n```\n#!c\n\nhxResult hxs_add_model(...);\nhxResult hxs_remove_model_id(int _id);\n\n```\n\n\nI see how that makes sense for Gazebo, but MuJoCo uses a compiled modeling language, so this kind of change cannot be made at runtime.  Instead we will need to define hidden bodies in the model and reveal them as needed -- which will require a different kind of API.  So let's leave this as simulator-specific extension.\n\n\n\n```\n#!c\n\nhxResult hxs_state(const hxModel *_model, const hxJoint *_joint);\nhxResult hxs_model_transform(int _id, const hxTransform *_transform);\nhxResult hxs_linear_velocity(int _id, const hxVector3 *_velocity);\nhxResult hxs_angular_velocity(int _id, const hxVector3 *_velocity);\n\n```\n\n\n\nSetting the state is a good idea in principle, but impossible to make standard, because different simulators have different state representation.  In ODE or Bullet, the state is the position and velocity of each body.  In MuJoCo or DART, the state is the position and velocity of each joint, and the body positions and velocities are obtained via forward kinematics.  So these should be simulator-specific extensions.  For Gazebo you may need two sets of such extensions actually, since you are supporting both types of physics engines.\n\n\n\n\n```\n#!c\n\nhxResult hxs_force(const hxLink *_link, const hxVector3 *_force);\nhxResult hxs_torque(const hxLink *_link, const hxVector3 *_torque);\n\n```\n\n\nThese are fine, but we should use symbolic names for the links instead of requiring a structure -- since the structure does not contain any information relevant to this function call beyond the link name.  Also, what happens after the forces and torques are applied; do they remain active until the user clears them?\n\nIn general, I would prefer to use the term \"body\" to refer to both passive bodies and bodies that are part of the robot. They are treated in the same way by the underlying engines.\n\n\n\n\n```\n#!c\n\nhxResult hxs_linear_accel(int _id, const hxVector3 *_accel);\nhxResult hxs_angular_accel(int _id, const hxVector3 *_accel);\n\n```\n\n\nThese do not make physical sense.  Accelerations are not part of the system state.  They can only be computed after the controls and external forces are specified by the user, and this computation is very elaborate (which is why we have physics engines in the first place).  So there is no way to specify accelerations and make them consistent with the rest of the simulation state.  I suggest removing these functions.\n\n\n\n```\n#!c\n\nhxResult hxs_reset(int _resetLimbPose);\n\n```\n\n\nWhat does it mean to reset the pose of the limb when motion capture is enabled?  We cannot physically move the user's hand to the desired pose...\n\nMuJoCo currently has an extension function for resetting, and it takes an argument which is the index of a keyframe.  This is used to reset the world (but not the limb) to a predefined configuration that is useful for a specific task.  If Gazebo does not support keyframes you can just ignore this argument.  So I propose:\n\n\n\n```\n#!c\n\nhxResult hxs_reset(int keyframe);\n\n```\n\nwhere keyframe == -1 is the configuration in which the model was defined, and keyframe >= 0 is the index of a keyframe specified in the model or GUI.\n\n\n\n\n```\n#!c\n\nstruct _hxContactPoint;\nstruct _hxContactPoints;\n\n```\n\nThese are fine, but we need to clarify what we mean by \"body\".  In MuJoCo one can have a body composed of several geoms that move together.  Contact points belong to geoms, which in turn belong to bodies... so does the body1,2 index refer to bodies or geoms?  Is there a similar distinction in Gazebo?\n\n\n\n```\n#!c\n\nstruct _hxCamera;\nhxResult hxs_camera(hxCamera *_camera);\nhxResult hxs_camera_transform(const hxTransform *_transform);\n\n```\n\n\nhxCamera is just a container for hxTransform, so we should get rid of it.  Instead we can have hxs_get_camera_transform and hxs_set_camera_transform (or frame instead of transform).\n\nOne complication here is that in addition to the \"free\" camera that the user can move around, MuJoCo allows body-fixed cameras to be defined in the model. The active camera is selected from the GUI. If the active camera is body-fixed, setting its transform is meaningless because the body itself can move around...  maybe we can just ignore this API call when a body-fixed camera is selected.\n\n\n\n\n```\n#!c\n\nstruct _hxModel;\nstruct _hxSimInfo;\nhxResult hxs_siminfo(hxSimInfo *_siminfo);\n\n```\n\nThese are too simulator-specific to be standardized; MuJoCo and Gazebo support different sets of model elements.  And we don't know what elements the users will want to have access to.  I suggest leaving it out of the standard and defining simulator-specific extensions that provide such functionality as needed.\n\n\n\n\n```\n#!c\n\nstruct _hxJacobian;\n\n```\n\n\nAs far as I know there is no easy way for OSRF to implement this when using ODE or Bullet.  MuJoCo computes Jacobians internally but I am thinking of restricting it to the Pro version which will require a paid license; or if HAPTIX users really need it, enable it in the API but only if an MPL-like model is being simulated (and I would rather avoid such hacks).  Either way, I propose removing this functionality from the standard.\n\n\n\n\n```\n#!c\n\nhxResult hxs_reset_timer();\nhxResult hxs_start_timer();\nhxResult hxs_stop_timer();\n\n```\n\nIn MuJoCo the timer is the simulation time, which resets automatically when the reset command is issued...  I can add a function to change the current time, but starting and stopping cannot be supported unless it also pauses the simulation (which is currently done from the GUI).\n\n\n\n\n```\n#!c\n\nhxResult hxs_start_logging(const char *_filename);\nhxResult hxs_is_logging(int *_result);\nhxResult hxs_stop_logging();\n\n```\n\n\nThis is important but I think it is premature to make it standard because we don't know what users will want in the log.  Also, it should be possible to create a log file from the GUI and record motion capture data, without the programmatic API.  If we allow such functionality both from the GUI and through the API it will be a mess.  So I propose limiting it to the GUI.  Another advantage of using the GUI is that we can have a standard File Open dialog which allows users to browse folders, create new folders, confirm before overwriting an existing file etc.  The latter functionality will be a pain to implement via the programmatic API.\n", "markup": "markdown", "html": "<p>SUMMARY:</p>\n<p>I wasn't sure if this is intended to be standardized, but Justin tells me it is.  I think we should aim for a much smaller \"world API\" that can have well-defined behavior with respect to both simulators.  We can add to it later if users want specific functionality that can be implemented on both sides.  But most such functionality will be simulator-specific because the two simulators represent and simulate the system in very different ways.</p>\n<p>As of now, the only functions I think should be standardized are:</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_set_camera</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">hxTransform</span><span class=\"o\">*</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_get_camera</span><span class=\"p\">(</span><span class=\"n\">hxTransform</span><span class=\"o\">*</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_get_contacts</span><span class=\"p\">(</span><span class=\"n\">hxContactPoints</span><span class=\"o\">*</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_set_force</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span><span class=\"o\">*</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_set_torque</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span><span class=\"o\">*</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_reset</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_get_body</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">hxBodyState</span><span class=\"o\">*</span><span class=\"p\">);</span> <span class=\"c1\">// or something like this</span>\n</pre></div>\n\n\n<p>DETAILS:</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxVector3</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">_hxQuaternion</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">_hxTransform</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>These are fine.  We may want to rename hxTransform to hxFrame though.  It is more natural to think of bodies as having position and orientation, instead of being translated and rotated relative to the world frame (although the two are mathematically equivalent).</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxJoint</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>hxSensor already contains most of this information, so I am not sure this is needed.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxLink</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>This is fine, although we should avoid mixing information about the state (i.e. position and velocity) with information that depends on the controls and applied forces (i.e. acceleration).  What if we include only the link position and velocity?  If users ask for acceleration beyond what the IMUs provide, we can provide it later, with a separate function:</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_get_acceleration</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">hxVector</span><span class=\"o\">*</span> <span class=\"n\">linear</span><span class=\"p\">,</span> <span class=\"n\">hxVector</span><span class=\"o\">*</span> <span class=\"n\">angular</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_add_model</span><span class=\"p\">(...);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_remove_model_id</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>I see how that makes sense for Gazebo, but MuJoCo uses a compiled modeling language, so this kind of change cannot be made at runtime.  Instead we will need to define hidden bodies in the model and reveal them as needed -- which will require a different kind of API.  So let's leave this as simulator-specific extension.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_state</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">hxModel</span> <span class=\"o\">*</span><span class=\"n\">_model</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxJoint</span> <span class=\"o\">*</span><span class=\"n\">_joint</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_model_transform</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxTransform</span> <span class=\"o\">*</span><span class=\"n\">_transform</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_linear_velocity</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_velocity</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_angular_velocity</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_velocity</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>Setting the state is a good idea in principle, but impossible to make standard, because different simulators have different state representation.  In ODE or Bullet, the state is the position and velocity of each body.  In MuJoCo or DART, the state is the position and velocity of each joint, and the body positions and velocities are obtained via forward kinematics.  So these should be simulator-specific extensions.  For Gazebo you may need two sets of such extensions actually, since you are supporting both types of physics engines.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_force</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">hxLink</span> <span class=\"o\">*</span><span class=\"n\">_link</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_force</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_torque</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">hxLink</span> <span class=\"o\">*</span><span class=\"n\">_link</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_torque</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>These are fine, but we should use symbolic names for the links instead of requiring a structure -- since the structure does not contain any information relevant to this function call beyond the link name.  Also, what happens after the forces and torques are applied; do they remain active until the user clears them?</p>\n<p>In general, I would prefer to use the term \"body\" to refer to both passive bodies and bodies that are part of the robot. They are treated in the same way by the underlying engines.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_linear_accel</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_accel</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_angular_accel</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_id</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">hxVector3</span> <span class=\"o\">*</span><span class=\"n\">_accel</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>These do not make physical sense.  Accelerations are not part of the system state.  They can only be computed after the controls and external forces are specified by the user, and this computation is very elaborate (which is why we have physics engines in the first place).  So there is no way to specify accelerations and make them consistent with the rest of the simulation state.  I suggest removing these functions.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_reset</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">_resetLimbPose</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>What does it mean to reset the pose of the limb when motion capture is enabled?  We cannot physically move the user's hand to the desired pose...</p>\n<p>MuJoCo currently has an extension function for resetting, and it takes an argument which is the index of a keyframe.  This is used to reset the world (but not the limb) to a predefined configuration that is useful for a specific task.  If Gazebo does not support keyframes you can just ignore this argument.  So I propose:</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_reset</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">keyframe</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>where keyframe == -1 is the configuration in which the model was defined, and keyframe &gt;= 0 is the index of a keyframe specified in the model or GUI.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxContactPoint</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">_hxContactPoints</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>These are fine, but we need to clarify what we mean by \"body\".  In MuJoCo one can have a body composed of several geoms that move together.  Contact points belong to geoms, which in turn belong to bodies... so does the body1,2 index refer to bodies or geoms?  Is there a similar distinction in Gazebo?</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxCamera</span><span class=\"p\">;</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_camera</span><span class=\"p\">(</span><span class=\"n\">hxCamera</span> <span class=\"o\">*</span><span class=\"n\">_camera</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_camera_transform</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">hxTransform</span> <span class=\"o\">*</span><span class=\"n\">_transform</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>hxCamera is just a container for hxTransform, so we should get rid of it.  Instead we can have hxs_get_camera_transform and hxs_set_camera_transform (or frame instead of transform).</p>\n<p>One complication here is that in addition to the \"free\" camera that the user can move around, MuJoCo allows body-fixed cameras to be defined in the model. The active camera is selected from the GUI. If the active camera is body-fixed, setting its transform is meaningless because the body itself can move around...  maybe we can just ignore this API call when a body-fixed camera is selected.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxModel</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">_hxSimInfo</span><span class=\"p\">;</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_siminfo</span><span class=\"p\">(</span><span class=\"n\">hxSimInfo</span> <span class=\"o\">*</span><span class=\"n\">_siminfo</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>These are too simulator-specific to be standardized; MuJoCo and Gazebo support different sets of model elements.  And we don't know what elements the users will want to have access to.  I suggest leaving it out of the standard and defining simulator-specific extensions that provide such functionality as needed.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"k\">struct</span> <span class=\"n\">_hxJacobian</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>As far as I know there is no easy way for OSRF to implement this when using ODE or Bullet.  MuJoCo computes Jacobians internally but I am thinking of restricting it to the Pro version which will require a paid license; or if HAPTIX users really need it, enable it in the API but only if an MPL-like model is being simulated (and I would rather avoid such hacks).  Either way, I propose removing this functionality from the standard.</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_reset_timer</span><span class=\"p\">();</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_start_timer</span><span class=\"p\">();</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_stop_timer</span><span class=\"p\">();</span>\n</pre></div>\n\n\n<p>In MuJoCo the timer is the simulation time, which resets automatically when the reset command is issued...  I can add a function to change the current time, but starting and stopping cannot be supported unless it also pauses the simulation (which is currently done from the GUI).</p>\n<div class=\"codehilite language-c\"><pre><span></span><span class=\"n\">hxResult</span> <span class=\"nf\">hxs_start_logging</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">_filename</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_is_logging</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">_result</span><span class=\"p\">);</span>\n<span class=\"n\">hxResult</span> <span class=\"nf\">hxs_stop_logging</span><span class=\"p\">();</span>\n</pre></div>\n\n\n<p>This is important but I think it is premature to make it standard because we don't know what users will want in the log.  Also, it should be possible to create a log file from the GUI and record motion capture data, without the programmatic API.  If we allow such functionality both from the GUI and through the API it will be a mess.  So I propose limiting it to the GUI.  Another advantage of using the GUI is that we can have a standard File Open dialog which allows users to browse folders, create new folders, confirm before overwriting an existing file etc.  The latter functionality will be a pain to implement via the programmatic API.</p>", "type": "rendered"}, "created_on": "2015-03-27T03:49:44.735436+00:00", "user": {"display_name": "Emo Todorov", "uuid": "{c84af488-b11e-458d-9817-1aeafde381d2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D"}, "html": {"href": "https://bitbucket.org/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D/"}, "avatar": {"href": "https://bitbucket.org/account/emotodorov/avatar/"}}, "nickname": "emotodorov", "type": "user", "account_id": null}, "updated_on": "2015-03-27T03:53:33.455360+00:00", "type": "pullrequest_comment", "id": 5918091}