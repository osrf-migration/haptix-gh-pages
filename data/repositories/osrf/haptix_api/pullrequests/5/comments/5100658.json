{"links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/5/comments/5100658.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/5/_/diff#comment-5100658"}}, "parent": {"id": 5099032, "links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/5/comments/5099032.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/5/_/diff#comment-5099032"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 5, "links": {"self": {"href": "data/repositories/osrf/haptix_api/pullrequests/5.json"}, "html": {"href": "#!/osrf/haptix_api/pull-requests/5"}}, "title": "Define MATLAB API"}, "content": {"raw": "Good.  Switching to scalar time_stamp field in the MATLAB sensor structure.  It is double btw, not float (MATLAB uses doubles by default, unless the user insists otherwise).\n\nScalar time is also more natural in C.  Did you try to write any user-side code using hxTime?  You cannot use while(t<10), or if(t1<t2), or t = t+dt, or if(t1==t2), or duration = t1-t2.  Any usable operation involving the timestamp requires conversion.\n\nIn my C implementation, I send the double from the simulator to the user-side communication library, and then convert it to hxTime, but also save it internally if the user wants it.  There is an extension called mjhx_last_time that returns the last double-precision time, similar to hx_last_result.  I am willing to bet you a beer (or a decaf soy milk latte if you prefer to stay healthy:) that most users will convert to double immediately after the hx_update call.\n\nSpeaking of conversion, it is easy to end up with something like nsec = 14999999 instead of nsec = 15000000, which is within a nanosecond but nevertheless is ugly if people print it out.  Getting it right requires computing both floor(x) and ceil(x) and choosing the one that is closer to x.  If you don't, and instead always use floor(x) for example, sometimes you end up with zeros and sometimes with nines.\n\nAnyway, let me know if you change your mind about the C version. I implemented the hxTime we agreed on, but would happily go back to scalar time.  There is no point creating the illusion of a nanosecond timer when we don't actually have one, and are merely converting from an underlying double stored in the physics engine...  or is Gazebo somehow using a system nanosecond clock for simulation purposes and modifying the way ODE works?", "markup": "markdown", "html": "<p>Good.  Switching to scalar time_stamp field in the MATLAB sensor structure.  It is double btw, not float (MATLAB uses doubles by default, unless the user insists otherwise).</p>\n<p>Scalar time is also more natural in C.  Did you try to write any user-side code using hxTime?  You cannot use while(t&lt;10), or if(t1&lt;t2), or t = t+dt, or if(t1==t2), or duration = t1-t2.  Any usable operation involving the timestamp requires conversion.</p>\n<p>In my C implementation, I send the double from the simulator to the user-side communication library, and then convert it to hxTime, but also save it internally if the user wants it.  There is an extension called mjhx_last_time that returns the last double-precision time, similar to hx_last_result.  I am willing to bet you a beer (or a decaf soy milk latte if you prefer to stay healthy:) that most users will convert to double immediately after the hx_update call.</p>\n<p>Speaking of conversion, it is easy to end up with something like nsec = <a href=\"#!/osrf/haptix_api/commits/14999999\" rel=\"nofollow\" class=\"ap-connect-link\">14999999</a> instead of nsec = <a href=\"#!/osrf/haptix_api/commits/15000000\" rel=\"nofollow\" class=\"ap-connect-link\">15000000</a>, which is within a nanosecond but nevertheless is ugly if people print it out.  Getting it right requires computing both floor(x) and ceil(x) and choosing the one that is closer to x.  If you don't, and instead always use floor(x) for example, sometimes you end up with zeros and sometimes with nines.</p>\n<p>Anyway, let me know if you change your mind about the C version. I implemented the hxTime we agreed on, but would happily go back to scalar time.  There is no point creating the illusion of a nanosecond timer when we don't actually have one, and are merely converting from an underlying double stored in the physics engine...  or is Gazebo somehow using a system nanosecond clock for simulation purposes and modifying the way ODE works?</p>", "type": "rendered"}, "created_on": "2015-02-12T02:27:33.223226+00:00", "user": {"display_name": "Emo Todorov", "uuid": "{c84af488-b11e-458d-9817-1aeafde381d2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D"}, "html": {"href": "https://bitbucket.org/%7Bc84af488-b11e-458d-9817-1aeafde381d2%7D/"}, "avatar": {"href": "https://bitbucket.org/account/emotodorov/avatar/"}}, "nickname": "emotodorov", "type": "user", "account_id": null}, "updated_on": "2015-02-12T02:27:33.230625+00:00", "type": "pullrequest_comment", "id": 5100658}